{"version":3,"file":"Sequencer.js","sourceRoot":"","sources":["../lib/Sequencer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Subject } from 'rxjs/Rx';\nimport { TimeEmission } from './api/Emission';\nimport { SegmentType, SegmentConfigShape, GroupParameter, SegmentInterface, SequenceConfigShape } from './api/Segment';\nimport { TimeSegment } from './Segments';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Observer, PartialObserver } from 'rxjs/Observer';\nimport { Subscribable } from './api/Subscribable';\n\n/**\n * Simply a pass-thru function to be used with-in a group functions parentheses.\n *\n * Adds a single segment (`CountupSegment` or `CountdownSegment`) to a sequence.\n * @param ctor    A type being subclass of `TimeSegment`, specifically `CountupSegment` or\n * `CountdownSegment`.\n * @param config  Config file specifiying `duration` (required) and `states` (optional).  When used\n * inside a group function, the `omitFirst` can be used to omit this segment when its assigned to\n * the first interval.\n * @returns       An instance of `T` type, which is a subclass of `TimeSegment`.\n */\nexport function add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): GroupParameter<T> {\n  return { ctor, config };\n}\n\nexport class SegmentCollection {\n  private segments: Array<TimeSegment>;\n\n  constructor(public config: SequenceConfigShape, private pauseObserv: Subject<boolean>) {\n    this.segments = new Array();\n  }\n\n  add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): T {\n    const segment: T = new ctor(config);\n    segment.collection = this;\n    segment.seqConfig = this.config;\n    segment.pauseObserv = this.pauseObserv;\n    this.segments.push(segment);\n\n    return segment;\n  }\n\n  group<T extends TimeSegment>(intervals: number = 1, ...segments: GroupParameter<T>[]): T {\n    let segment: TimeSegment;\n    // TODO: possibly use the 'repeat' operator in here..\n    for (let index = 0; index < intervals; index++) {\n      segments.forEach((value: GroupParameter<T>) => {\n        if ((index != 0) || (!value.config.omitFirst)) {\n          segment = this.add(value.ctor, value.config) as TimeSegment;\n          (segment as TimeSegment).interval = { current: index + 1, total: intervals };\n        }\n      });\n    }\n\n    // return the last instance, so that this group invocation can be chained if needed...\n    return segment! as T;\n  }\n\n  toSequencedObservable(): Observable<TimeEmission> {\n    let concatObservs: Observable<TimeEmission> | undefined;\n\n    this.segments.forEach((value: TimeSegment, index: number) => {\n      let observable: Observable<TimeEmission>;\n\n      if (index === this.segments.length - 1) {\n        if (index !== 0) {\n          observable = value.initializeObservable(false, true);\n        } else {\n          observable = value.initializeObservable(true, true);\n        }\n      } else {\n        if (index !== 0) {\n          observable = value.initializeObservable();\n        } else {\n          observable = value.initializeObservable(true);\n        }\n      }\n\n      if (concatObservs) {\n        concatObservs = concatObservs.concat(observable);\n      } else {\n        concatObservs = Observable.concat(observable);\n      }\n    });\n\n    return concatObservs!;\n  }\n\n  /** @internal */\n  __marauder(): { segments: Array<TimeSegment> } {\n    return { segments: this.segments };\n  }\n}\n\n/**\n * Initiates a sequence with time period being defined in its constructor.\n * @param constructor  Sequencer must be instantiated with a value for period that is read in\n * milliseconds.  This value becomes static and global to its segments.\n */\nexport class Sequencer implements SegmentInterface, Subscribable {\n  collection: SegmentCollection;\n  subscription: Subscription;\n  private pauseObserv: Subject<boolean>;\n  private source: Observable<TimeEmission>;\n  private observer: Observer<TimeEmission>;\n\n  constructor(public config: SequenceConfigShape) {\n    this.pauseObserv = new Subject<boolean>();\n    this.collection = new SegmentCollection(config, this.pauseObserv);\n  }\n  /**\n   * Adds a single segment (`CountupSegment` or `CountdownSegment`) to a sequence.\n   * @param ctor    A type being subclass of `TimeSegment`,  Specifically `CountupSegment` or\n   * `CountdownSegment`.\n   * @param config  Config file specifiying `duration` (required) and `states` (optional).  When\n   * used inside a group function, the `omitFirst` can be used to omit this segment when its\n   * assigned to the first interval.\n   * @returns       An instance of `T` type, which is a subclass of TimeSegment.\n   */\n  add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): T {\n    return this.collection.add(ctor, config);\n  }\n\n  /**\n   * Multiply its combined `add()` invocations and returns a `TimeSegment`.\n   * @param intervals The number intervals or cycles to be added of segments.  Must be 1 or greater\n   * in value.\n   * @param segments  Consists of `add()` invocations returns.\n   * @returns         An instance of `T` type, which is a subclass of `TimeSegment`.\n   */\n  group<T extends TimeSegment>(intervals: number = 1, ...segments: GroupParameter<T>[]): T {\n    return this.collection.group(intervals, ...segments);\n  }\n\n  /**\n   * Starts internal Observable to start emitting.  This must be called after the `subscribe()` or\n   * `subscribeWith()` is called.\n   * @returns void.\n   */\n  start(): void {\n    if (this.source) {\n      this.pauseObserv.next(true);\n    } else {\n      throw \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n    }\n  }\n\n  /**\n   * Pauses internal Observable to start emitting.  This must be called after the `subscribe()` or\n   * `subscribeWith()` is called.\n   * @returns void.\n   */\n  pause(): void {\n    if (this.source) {\n      this.pauseObserv.next(false);\n    } else {\n      throw \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n    }\n  }\n\n  /**\n   * Resets the sequence.  This must be called after the `subscribeWith()` is called since a\n   * callback object is needed.\n   * That said, this method will unsubscribe and then subscribe again to \"reset\" the sequence.\n   * @returns void.\n   */\n  reset(): void {\n    if (this.source && this.observer) {\n      this.unsubscribe();\n      this.subscribe(this.observer);\n    } else {\n      let mesg: string = \"\";\n      if (!this.source) {\n        mesg += \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n      }\n\n      if (!this.observer) {\n        mesg += (mesg.length > 0) ? \"  Also, in \" : \"  In \";\n        mesg += \"order to reset, an observer instance is needed.  See documentation on subscribe(observer).\";\n      }\n      throw mesg;\n    }\n  }\n\n  /**\n   * Returns an Observable<TimeEmission> object versus a Subscription object which `subscribe()`\n   * returns.  Typically `subscribe()` is just used.\n   * @returns Observable<TimeEmission>.\n   */\n  publish(): Observable<TimeEmission> {\n    this.source = this.collection.toSequencedObservable();\n\n    return this.source.zip(this.pauseObserv.switchMap(\n      (value) => (value) ? Observable.interval(this.config.period) : Observable.never<number>()\n    ), (value: TimeEmission) => value);\n  }\n\n  /**\n   * Pass in callback functions to \"subscribe\" to emissions from sots.\n   *\n   * @returns Subscription.\n   */\n  subscribe(observer: PartialObserver<TimeEmission>): Subscription;\n  subscribe(next?: (value: TimeEmission) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  subscribe(nextOrObserver: any, error?: (error: any) => void, complete?: () => void): Subscription {\n    if (typeof nextOrObserver !== 'function') {\n      this.observer = nextOrObserver;\n    }\n\n    if (!this.source) {\n      this.publish();\n    }\n\n    this.subscription = this.source.subscribe(nextOrObserver, error, complete);\n\n    return this.subscription;\n  }\n\n  /**\n   * Unsubscribe the subscription that is create from `subscribe()` or `subscribeWith()`.  This also\n   * calls the `remove()`\n   * method.\n   */\n  unsubscribe(): void {\n    this.remove();\n    this.subscription.unsubscribe();\n  }\n\n  /**\n   * Calls the remove method on the subscription object that was create from `subscribe()` or\n   * `subscribeWith()`.\n   */\n  remove(): void {\n    this.subscription.remove(this.subscription);\n  }\n\n  /** @internal */\n  __marauder(): { pauseObserv: Subject<boolean>, source: Observable<TimeEmission> } {\n    return { pauseObserv: this.pauseObserv, source: this.source };\n  }\n}\n"]}