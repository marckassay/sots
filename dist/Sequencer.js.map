{"version":3,"file":"Sequencer.js","sourceRoot":"","sources":["../lib/Sequencer.ts"],"names":[],"mappings":"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","sourcesContent":["import { interval, never, Observable, Observer, PartialObserver, Subject, Subscription, zip } from 'rxjs';\nimport { concat, switchMap } from 'rxjs/operators';\nimport { TimeEmission } from './api/Emission';\nimport { GroupParameter, SegmentConfigShape, SegmentInterface, SegmentType, SequenceConfigShape } from './api/Segment';\nimport { Subscribable } from './api/Subscribable';\nimport { TimeSegment } from './Segments';\n\n/**\n * Simply a pass-thru function to be used with-in a group functions parentheses.\n *\n * Adds a single segment (`CountupSegment` or `CountdownSegment`) to a sequence.\n * @param ctor    A type being subclass of `TimeSegment`, specifically `CountupSegment` or\n * `CountdownSegment`.\n * @param config  Config file specifiying `duration` (required) and `states` (optional).  When used\n * inside a group function, the `omitFirst` can be used to omit this segment when its assigned to\n * the first interval.\n * @returns       An instance of `T` type, which is a subclass of `TimeSegment`.\n */\nexport function add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): GroupParameter<T> {\n  return { ctor, config };\n}\n\nexport class SegmentCollection {\n  private segments: Array<TimeSegment>;\n\n  constructor(public config: SequenceConfigShape, private pauseObserv: Subject<boolean>) {\n    this.segments = new Array();\n  }\n\n  add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): T {\n    const segment: T = new ctor(config);\n    segment.collection = this;\n    segment.seqConfig = this.config;\n    segment.pauseObserv = this.pauseObserv;\n    this.segments.push(segment);\n\n    return segment;\n  }\n\n  group<T extends TimeSegment>(intervals: number = 1, ...segments: GroupParameter<T>[]): T {\n    let segment: TimeSegment;\n    // TODO: possibly use the 'repeat' operator in here..\n    for (let index = 0; index < intervals; index++) {\n      segments.forEach((value: GroupParameter<T>) => {\n        if ((index != 0) || (!value.config.omitFirst)) {\n          segment = this.add(value.ctor, value.config) as TimeSegment;\n          (segment as TimeSegment).interval = { current: index + 1, total: intervals };\n        }\n      });\n    }\n\n    // return the last instance, so that this group invocation can be chained if needed...\n    return segment! as T;\n  }\n\n  toSequencedObservable(): Observable<TimeEmission> {\n    let concatObservs: Observable<TimeEmission> | undefined;\n\n    this.segments.forEach((value: TimeSegment, index: number) => {\n      let observable: Observable<TimeEmission>;\n\n      if (index === this.segments.length - 1) {\n        if (index !== 0) {\n          observable = value.initializeObservable(false, true);\n        } else {\n          observable = value.initializeObservable(true, true);\n        }\n      } else {\n        if (index !== 0) {\n          observable = value.initializeObservable();\n        } else {\n          observable = value.initializeObservable(true);\n        }\n      }\n\n      if (concatObservs) {\n        concatObservs = concatObservs.pipe(concat(observable));\n      } else {\n        concatObservs = observable;\n      }\n    });\n\n    return concatObservs!;\n  }\n\n  /** @internal */\n  __marauder(): { segments: Array<TimeSegment> } {\n    return { segments: this.segments };\n  }\n}\n\n/**\n * Initiates a sequence with time period being defined in its constructor.\n * @param constructor  Sequencer must be instantiated with a value for period that is read in\n * milliseconds.  This value becomes static and global to its segments.\n */\nexport class Sequencer implements SegmentInterface, Subscribable {\n  collection: SegmentCollection;\n  subscription: Subscription;\n  private pauseObserv: Subject<boolean>;\n  private source: Observable<TimeEmission>;\n  private observer: Observer<TimeEmission>;\n\n  constructor(public config: SequenceConfigShape) {\n    this.pauseObserv = new Subject<boolean>();\n    this.collection = new SegmentCollection(config, this.pauseObserv);\n  }\n  /**\n   * Adds a single segment (`CountupSegment` or `CountdownSegment`) to a sequence.\n   * @param ctor    A type being subclass of `TimeSegment`,  Specifically `CountupSegment` or\n   * `CountdownSegment`.\n   * @param config  Config file specifiying `duration` (required) and `states` (optional).  When\n   * used inside a group function, the `omitFirst` can be used to omit this segment when its\n   * assigned to the first interval.\n   * @returns       An instance of `T` type, which is a subclass of TimeSegment.\n   */\n  add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): T {\n    return this.collection.add(ctor, config);\n  }\n\n  /**\n   * Multiply its combined `add()` invocations and returns a `TimeSegment`.\n   * @param intervals The number intervals or cycles to be added of segments.  Must be 1 or greater\n   * in value.\n   * @param segments  Consists of `add()` invocations returns.\n   * @returns         An instance of `T` type, which is a subclass of `TimeSegment`.\n   */\n  group<T extends TimeSegment>(intervals: number = 1, ...segments: GroupParameter<T>[]): T {\n    return this.collection.group(intervals, ...segments);\n  }\n\n  /**\n   * Starts internal Observable to start emitting.  This must be called after the `subscribe()` or\n   * `subscribeWith()` is called.\n   * @returns void.\n   */\n  start(): void {\n    if (this.source) {\n      this.pauseObserv.next(true);\n    } else {\n      throw \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n    }\n  }\n\n  /**\n   * Pauses internal Observable to start emitting.  This must be called after the `subscribe()` or\n   * `subscribeWith()` is called.\n   * @returns void.\n   */\n  pause(): void {\n    if (this.source) {\n      this.pauseObserv.next(false);\n    } else {\n      throw \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n    }\n  }\n\n  /**\n   * Resets the sequence.  This must be called after the `subscribeWith()` is called since a\n   * callback object is needed.\n   * That said, this method will unsubscribe and then subscribe again to \"reset\" the sequence.\n   * @returns void.\n   */\n  reset(): void {\n    if (this.source && this.observer) {\n      this.unsubscribe();\n      this.subscribe(this.observer);\n    } else {\n      let mesg: string = \"\";\n      if (!this.source) {\n        mesg += \"A call to subscribe() needs to be made prior to start(), pause() or reset().\";\n      }\n\n      if (!this.observer) {\n        mesg += (mesg.length > 0) ? \"  Also, in \" : \"  In \";\n        mesg += \"order to reset, an observer instance is needed.  See documentation on subscribe(observer).\";\n      }\n      throw mesg;\n    }\n  }\n\n  /**\n   * Returns an Observable<TimeEmission> object versus a Subscription object which `subscribe()`\n   * returns.  Typically `subscribe()` is just used.\n   * @returns Observable<TimeEmission>.\n   */\n  publish() /* Observable<TimeEmission> */ {\n    this.source = this.collection.toSequencedObservable();\n\n    return zip(\n      this.source,\n      this.pauseObserv.pipe(\n        switchMap((value) => (value) ? interval(this.config.period) : never())\n      )\n    );\n  }\n\n  /**\n   * Pass in callback functions to \"subscribe\" to emissions from sots.\n   *\n   * @returns Subscription.\n   */\n  subscribe(observer: PartialObserver<TimeEmission>): Subscription;\n  subscribe(next?: (value: TimeEmission) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  subscribe(nextOrObserver: any, error?: (error: any) => void, complete?: () => void): Subscription {\n    if (typeof nextOrObserver !== 'function') {\n      this.observer = nextOrObserver;\n    }\n\n    if (!this.source) {\n      this.publish();\n    }\n\n    this.subscription = this.source.subscribe(nextOrObserver, error, complete);\n\n    return this.subscription;\n  }\n\n  /**\n   * Unsubscribe the subscription that is create from `subscribe()` or `subscribeWith()`.  This also\n   * calls the `remove()`\n   * method.\n   */\n  unsubscribe(): void {\n    this.remove();\n    this.subscription.unsubscribe();\n  }\n\n  /**\n   * Calls the remove method on the subscription object that was create from `subscribe()` or\n   * `subscribeWith()`.\n   */\n  remove(): void {\n    this.subscription.remove(this.subscription);\n  }\n\n  /** @internal */\n  __marauder(): { pauseObserv: Subject<boolean>, source: Observable<TimeEmission> } {\n    return { pauseObserv: this.pauseObserv, source: this.source };\n  }\n}\n"]}