{"version":3,"file":"Sequencer.js","sourceRoot":"","sources":["../lib/Sequencer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Subject } from 'rxjs/Rx';\r\nimport { TimeEmission } from './api/Emission';\r\nimport { SegmentType, SegmentConfigShape, GroupParameter, SegmentInterface } from './api/Segment';\r\nimport { TimeSegment } from './Segments';\r\n\r\nexport class SegmentCollection {\r\n    private static instance: SegmentCollection;\r\n\r\n    segments: Array<TimeSegment>;\r\n    observables: any;\r\n    lastTimeSegment: TimeSegment;\r\n\r\n    private constructor() {\r\n        this.segments = new Array();\r\n        this.observables = new Array();\r\n    }\r\n\r\n    static getInstance() {\r\n        if (!SegmentCollection.instance) {\r\n            SegmentCollection.instance = new SegmentCollection();\r\n        }\r\n        return SegmentCollection.instance;\r\n    }\r\n\r\n    toSequencedObservable(): Observable<TimeEmission> {\r\n        const len: number = this.observables.length;\r\n\r\n        if (len >= 1) {\r\n            let source: Observable<TimeEmission> = this.observables[0];\r\n            for (let index = 0; index <= len - 1; index++) {\r\n                source = source.concat(this.observables[index]);\r\n            }\r\n            return source;\r\n        } else {\r\n            throw new Error(\"There are no observables to sequence.  Check your configuration.\");\r\n        }\r\n    }\r\n\r\n    push(segment: TimeSegment): void {\r\n        this.segments.push(segment);\r\n        this.observables.push(segment.source);\r\n        this.lastTimeSegment = segment;\r\n    }\r\n\r\n    getLastSegment(): TimeSegment {\r\n        return this.lastTimeSegment;\r\n    }\r\n}\r\n\r\nexport class Sequencer implements SegmentInterface {\r\n    static period: number;\r\n    pauser: Subject<boolean>;\r\n    publication: Observable<TimeEmission>;\r\n    source: Observable<TimeEmission>;\r\n\r\n    constructor(config: { period: number }) {\r\n        Sequencer.period = config.period;\r\n    }\r\n    add<T extends TimeSegment>(ctor: SegmentType<T>, config: SegmentConfigShape): T {\r\n        const segment: T = new ctor(config);\r\n        SegmentCollection.getInstance().push(segment);\r\n        return segment;\r\n    }\r\n\r\n    // TODO: this method is complete boilder-plate code.  I need to consider Sequencer\r\n    // as a subclass (or composite) of TimeSegment.\r\n    group<T extends TimeSegment>(intervals: number, ...segments: GroupParameter<T>[]): T {\r\n        let segment: TimeSegment;\r\n\r\n        for (let index = 0; index < intervals; index++) \r\n        {\r\n            segments.forEach( (value:GroupParameter<T>) => {\r\n                if ((index != 0) || (!value.config.omitFirst)) {\r\n                    segment = new value.ctor(value.config) as TimeSegment;\r\n                    segment.interval = { current: index + 1, total: intervals };\r\n                    SegmentCollection.getInstance().push(segment);\r\n                }\r\n            });\r\n        }\r\n        // return the last instance, so that this group invocation can be chained if needed...\r\n        return SegmentCollection.getInstance().getLastSegment() as T;\r\n    }\r\n\r\n    start(): void {\r\n        this.pauser.next(false);\r\n    }\r\n\r\n    pause(): void {\r\n        this.pauser.next(true);\r\n    }\r\n\r\n    publish(): Observable<TimeEmission> {\r\n        if (!this.source) {\r\n            this.source = SegmentCollection.getInstance().toSequencedObservable();\r\n            this.pauser = new Subject<boolean>();\r\n            this.pauser.next(true);\r\n            this.publication = this.pauser.switchMap((paused: boolean) => (paused == true) ? Observable.never() : this.source);\r\n        }\r\n\r\n        return this.publication;\r\n    }\r\n}"]}